<!DOCTYPE html>
<html>
<head>
	<script src="https://cdn.jsdelivr.net/npm/chart.js@2.8.0"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r122/three.min.js"></script>
	<title></title>
</head>
<body style="margin: 0;">
	<script type="text/javascript">
		/*
			TODO:
				- custom planet generation controls
					- (Re)Generate // (Re)Colour
					- custom variables
					- planet specific colours
				- water level
				- colour blending
				- better dragging controls

				- gravity???
		*/

		const 	use_colours = true,
				apply_amp = true,
				colour_threshholds = [
					{
						'threshhold' : 92,
						'colour' : 'white'
					},
					{
						'threshhold' : 86,
						'colour' : 'lightgrey'
					},
					{
						'threshhold' : 76,
						'colour' : 'saddlebrown'
					},
					{
						'threshhold' : 60,
						'colour' : 'forestgreen'
					},
					{
						'threshhold' : 55,
						'colour' : 'khaki'
					},
					{
						'threshhold' : 30,
						'colour' : 'blue'
					},
					{
						'threshhold' : 0,
						'colour' : 'navy'
					},
				],
				rotation_values = [
					[ 0, 0, 0 ],
					[ 1.5708 * 2, 0, 0 ],
					[ 1.5708, 0, 0 ],
					[ 0, 0, 1.5708 ],
					[ 0, 0, -1.5708 ],
					[ -1.5708, 0, 0 ],
				],
				colours = [ 0x00ff00, 0xff00ff, 0x0000ff, 0xff0000, 0xffff00, 0x00ffff ],
				sides_to_render = 6;

		// Get an amplitude base on current generation stage
		const generate_point_amp = ( layer_options, i ) => {
			const 	amp_multiplier = ( layer_options.base_amp * ( 1 / Math.pow( layer_options.amp_diff, i ) ) );

			return Math.random() * amp_multiplier - ( amp_multiplier / 2 );
		}

		// Creates missing rows
		const create_fill_layer = ( steps, previous_array, next_array, final_freq_count, layer_options ) => {
			return fill_layer = new Array( final_freq_count ).fill().map( ( i, index ) => {
				const 	y_distance_in_points = ( next_array[ index ] - previous_array[ index ] ) * -1,
						step_distance = y_distance_in_points / ( Math.pow( layer_options.freq_diff, ( layer_options.base_layers - 1 ) ) );
				
				return previous_array[ index ] - ( step_distance * steps );
			} );
		}

		// Translate data from cube to sphere
		const map_data_onto_sphere = ( grid_data, layer_options, final_freq_count ) => {
			const 	quadrant_cutoff_index = Math.ceil( final_freq_count / 2 ),
					panel_quadrant_one = [...grid_data].slice( 0, quadrant_cutoff_index ).map( ( item ) => [...item].slice( 0, quadrant_cutoff_index ) );

			grid_data.forEach( ( quadrant_row, index ) => {
				quadrant_row.forEach( ( quadrant_row_index, sub_index ) => {
					const 	xz_length_to_center = ( quadrant_row_index.x * quadrant_row_index.x ) + ( quadrant_row_index.z * quadrant_row_index.z ),
							xzy_length_to_center = Math.sqrt( ( quadrant_row_index.y * quadrant_row_index.y ) + xz_length_to_center ),
							coords_multiplier =  layer_options.radius / ( xzy_length_to_center - quadrant_row_index.amp_value );

					quadrant_row_index.y = quadrant_row_index.y * coords_multiplier;
					quadrant_row_index.x = quadrant_row_index.x * coords_multiplier; 
					quadrant_row_index.z = quadrant_row_index.z * coords_multiplier; 
				} );
			} );
		}

		// Calculate the colour base on average height of all face points
		const get_colour_by_height = ( a, b, c, layer_options ) => {
			const 	average_height = ( ( ( a.amp_value + b.amp_value + c.amp_value ) / 3 ) ) + ( layer_options.base_amp / 2 ),
					average_height_as_percent_max_amp = ( average_height / layer_options.base_amp ) * 100;

			for ( let i = 0; i < colour_threshholds.length; i ++ ) {
				if ( average_height_as_percent_max_amp > colour_threshholds[ i ].threshhold || i == colour_threshholds.length - 1 ) return colour_threshholds[ i ].colour;
			}
		}

		// Plot point and faces in space
		const plot_points = ( grid_data, final_freq_count, layer_options, rotation_values_index, scene, apply_amp = false ) => {
			const geometry = new THREE.Geometry();

			[...grid_data].flat().forEach( ( item ) => {
				geometry.vertices.push( new THREE.Vector3( item.x, item.y + ( apply_amp ? item.amp_value : 0 ), item.z ) );
			} );

			for ( let i = 1; i < grid_data.length; i ++ ) {
				for ( let j = 0; j < grid_data[ i ].length - 1; j ++ ) {
					const points = {
						'oo' : grid_data[ i ][ j ],
						'oi' : grid_data[ i - 1 ][ j ],
						'io' : grid_data[ i ][ j + 1 ],
						'ii' : grid_data[ i - 1 ][ j + 1 ],
					};

					geometry.faces.push(
						new THREE.Face3( points.oo.index, points.oi.index, points.ii.index ),
						new THREE.Face3( points.oo.index, points.io.index, points.ii.index ),
					);

					geometry.faces[ geometry.faces.length - 2 ].color = new THREE.Color( get_colour_by_height( points.oo, points.oi, points.ii, layer_options ) );
					geometry.faces[ geometry.faces.length - 1 ].color = new THREE.Color( get_colour_by_height( points.oo, points.io, points.ii, layer_options ) );
				}
			}

			const material = new THREE.MeshBasicMaterial( use_colours ? {
				vertexColors: THREE.FaceColors,
				side: THREE.DoubleSide
			} : {
				color: colours[ rotation_values_index ],
				wireframe: true,
			} ),
			terrain = new THREE.Mesh( geometry, material );

			scene.add( terrain );

			apply_rotation_to_side( terrain, rotation_values_index );
		}

		// Align each side properly
		const apply_rotation_to_side = ( terrain, i ) => {
			const current_rotation_values = rotation_values[ i ];

			terrain.rotation.x = current_rotation_values[ 0 ];	
			terrain.rotation.y = current_rotation_values[ 1 ];
			terrain.rotation.z = current_rotation_values[ 2 ];
		}

		// Adds rotational drag controls
		const apply_drag_controls = ( scene ) => {
			let click_coords = {
				'x' : null,
				'y' : null,
			},
			can_drag = false;

			document.addEventListener( 'mousedown', ( event ) => {
				can_drag = true;

				click_coords = {
					'x' : event.clientX,
					'y' : event.clientY,
				};
			} );

			document.addEventListener( 'mouseup', ( event ) => {
				can_drag = false;
			} );

			document.addEventListener( 'mousemove', ( event ) => {
				if ( can_drag ) {
					scene.rotation.y += ( ( click_coords.x - event.clientX ) / 400 );
					scene.rotation.x += ( ( click_coords.y - event.clientY ) / 400 );

					click_coords = {
						'x' : event.clientX,
						'y' : event.clientY,
					};
				} 
			} );
		}

		// Generate coords for each point
		const generate_point_data = ( layer_options, final_freq_count ) => {
			let sides = [];

			for ( let i = 0; i < layer_options.base_layers; i ++ ) {
				const amount_to_skip = Math.pow( layer_options.freq_diff, ( layer_options.base_layers - ( i ) ) - 1  );

				for ( let j = 0; j < sides_to_render; j ++ ) {
					if ( i == 0 ) sides.push( {} );

					const injection_data = get_injection_data( j )

					sides[ j ][ 'layer_' + i ] = generate_mesh( layer_options, amount_to_skip, final_freq_count, i, injection_data, sides, j );
				}
			}

			const step = ( ( layer_options.radius * 2 ) / ( final_freq_count - 1 ) );

			sides.forEach( ( side ) => {
				side[ 'data' ] = side.layer_0.map( ( item, index ) => {
					return item.map( ( sub_item, sub_index ) => {
						return {
							'amp_value' : get_total_amp( layer_options, side, index, sub_index ),
							'y' : layer_options.radius,
							'x' : ( step * sub_index ) - layer_options.radius,
							'z' : ( step * index ) - layer_options.radius,
							'index' : sub_index + ( index * final_freq_count ), 
						}
					} );
				} );
			} );

			return sides;			
		}

		// Add all layer amp values
		const get_total_amp = ( layer_options, side, index, sub_index ) => {
			let placeholder_amp = 0;

			for ( let i = 0; i < layer_options.base_layers; i ++ ) {
				placeholder_amp += side[ 'layer_' + i ][ index ][ sub_index ];
			}

			return placeholder_amp;
		}

		// Get data to know how to stitch
		const get_injection_data = ( side_index ) => {
			switch ( side_index ) {
				case 0 :
				case 1 :
					return null;
				case 2 : // front
					return [ [ 2, 0 ], null, [ 0, 1 ], null ]; // where [ 1, 1 ] means the first face from the first panel
				case 3 : // left
					return [ null, [ 3, 0 ], [ 3, 2, true ], [ 3, 1, true ] ];
				case 4 : // right
					return [ null, [ 1, 1, true ], [ 1, 2 ], [ 1, 0 ] ];
				case 5 : // back
					return [ [ 2, 1 ], [ 0, 4, true ], [ 0, 0 ], [ 0, 3 ] ];
				default :
					console.error( 'Something fucked up...' );
					return;
			}
		}

		// Get entire row for stitching
		const get_spliced_data = ( data, side_index, is_negative ) => {
			switch ( side_index ) {
				case 0 :
					return data[ 0 ];
				case 1 :
					return data.map( ( item ) => item[ item.length - 1 ] );
				case 2 :
					return data[ data.length - 1 ];
				case 3 :
					const arr = data.map( ( item ) => item[ 0 ] );

					return ( is_negative ? arr.reverse() : arr );
			}
		}

		// Get single point for stitching
		const get_row_spliced_data = ( data, side_index, current_row_index, is_negative ) => {
			switch ( side_index ) {
				case 0 :
					return data[ 0 ][ ( is_negative ? data[ 0 ].length - 1 - current_row_index : current_row_index ) ];
				case 1 :
					return data[ ( is_negative ? data.length - 1 - current_row_index : current_row_index ) ][ data[ 0 ].length - 1 ];
				case 2 :
					return data[ data.length - 1 ][ ( is_negative ? data[ 0 ].length - current_row_index : current_row_index ) ];
				case 3 :
					return data[ is_negative ? data.length - 1 - current_row_index : current_row_index ][ 0 ];
			}
		}

		// Generate panel layer mesh
		const generate_mesh = ( layer_options, amount_to_skip, final_freq_count, layer_index, injection_data, sides, side_index ) => {
			let mesh = new Array( final_freq_count );

			for ( let i = 0; i < final_freq_count; i += amount_to_skip ) { // Loop through rows
				if ( i == 0 && injection_data && injection_data[ 0 ] ) {
					const cloned_panel_data = sides[ injection_data[ 0 ][ 1 ] ];

					mesh[ i ] = get_spliced_data( cloned_panel_data[ 'layer_' + layer_index ], injection_data[ 0 ][ 0 ], injection_data[ 0 ][ 2 ] );
				} else if ( i == final_freq_count - 1 && injection_data && injection_data[ 2 ] ) {
					const cloned_panel_data = sides[ injection_data[ 2 ][ 1 ] ];

					mesh[ i ] = get_spliced_data( cloned_panel_data[ 'layer_' + layer_index ], injection_data[ 2 ][ 0 ], injection_data[ 2 ][ 2 ] );
				} else {
					let mesh_row = new Array( final_freq_count ).fill( 0 );

					for ( let j = 0; j < final_freq_count; j += amount_to_skip ) { // loop through single row
						if ( j == 0 && injection_data && injection_data[ 3 ] ) {
							const cloned_panel_data = sides[ injection_data[ 3 ][ 1 ] ];

							mesh_row[ j ] = get_row_spliced_data( cloned_panel_data[ 'layer_' + layer_index ], injection_data[ 3 ][ 0 ], i, injection_data[ 3 ][ 2 ] );
						} else if ( j == final_freq_count - 1 && injection_data && injection_data[ 1 ] ) {
							const cloned_panel_data = sides[ injection_data[ 1 ][ 1 ] ];

							mesh_row[ j ] = get_row_spliced_data( cloned_panel_data[ 'layer_' + layer_index ], injection_data[ 1 ][ 0 ], i, injection_data[ 1 ][ 2 ] );
						} else {
							mesh_row[ j ] = generate_point_amp( layer_options, layer_index );
						}

						if ( j != 0 && amount_to_skip != 1 ) {
							const 	previous_point = mesh_row[ j - amount_to_skip ],
									current_point = mesh_row[ j ],
									step = ( previous_point - current_point ) / amount_to_skip;

							for ( let z = 0; z < amount_to_skip - 1; z ++ ) {
								mesh_row[ j - ( ( amount_to_skip - 1 - z ) ) ] = ( current_point + ( step * ( amount_to_skip - 1 - z ) ) );
							}
						}
					}

					mesh[ i ] = mesh_row;
				}

				if ( i != 0 && amount_to_skip != 1 ) {
					const 	previous_layer = mesh[ i - amount_to_skip ],
							current_layer = mesh[ i ];

					for ( let z = 0; z < amount_to_skip - 1; z ++ ) {
						mesh[ i - ( ( amount_to_skip - 1 - z ) ) ] = create_fill_layer( z + 1, previous_layer, current_layer, final_freq_count, layer_options );
					} 
				}
			}

			return mesh;
		}

		// Master planet creator
		const create_planet = () => {
			const layer_options = {
				'base_amp' : 40,
				'amp_diff' : 2,
				'base_freq' : 16,
				'freq_diff' : 2,
				'base_layers' : 5,
				'water_level' : 25,
				'radius' : 600,
			},
			final_freq_count = layer_options.base_layers == 1 ? layer_options.base_freq : ( layer_options.base_freq * ( Math.pow( layer_options.freq_diff, layer_options.base_layers ) ) / 2 - ( new Array( layer_options.base_layers ).fill().map( ( i, index ) => Math.floor( Math.pow( layer_options.freq_diff, ( index - 1 ) ) ) ).reduce( ( a, b ) => a + b ) ) );

			const 	scene = new THREE.Scene(),
					camera = new THREE.PerspectiveCamera( 100, window.innerWidth / window.innerHeight, .1, 1000 ),
					renderer = new THREE.WebGLRenderer(),
					grid_data = generate_point_data( layer_options, final_freq_count );
			
			renderer.setSize( window.innerWidth, window.innerHeight );
			document.body.appendChild( renderer.domElement );

			camera.position.z = 1000;

			for ( let i = 0; i < sides_to_render; i ++ ) {
				map_data_onto_sphere( grid_data[ i ][ 'data' ], layer_options, final_freq_count );
				plot_points( grid_data[ i ][ 'data' ], final_freq_count, layer_options, i, scene )
			}

			apply_drag_controls( scene );

			function animate() {
				requestAnimationFrame( animate );
				renderer.render( scene, camera );
			}
			animate();
		}

		create_planet();
	</script>
</body>
</html>